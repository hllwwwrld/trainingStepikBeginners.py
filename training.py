# Интересное задание из экзамена
# Пограмма получает число n от 1 до 9, должна вывести n + nn + nnn, то есть 1 + 11 + 111 = 123
n = int(input())  # получаю на вход число
n1 = str(n)  # перевожу его в переменную строковую
n2 = str(n)*2  # строковую переменную умножаю на два (строка * 2 = строкастрока)
n3 = str(n)*3  # так - же умножаю на три
fin_number = int(n1) + int(n2) + int(n3)  # перевожу созданные строковые переменные обратно в числа и складываю
print(fin_number)

# 2.3 шаг 1
# Параметры sep/end

print('a', 'b', 'c', sep='*')
# a*b*c
print('a', 'b', 'c', end='@')
# a, b, c@
print('a', 'b', 'c', sep='\n')
#  a
#  b
#  c

# sep=' ' пробел
# end='\n'# перевод строки

print('Python', end='\n\n\n')  # Если после вывода нужно больше одной пустой строки

# 2.3 шаг 8
# name1, name2 = 1, 2

# множественное присваивание для обмена значений переменных:
name1 = 'Timur'
name2 = 'Gvido'
name1, name2 = name2, name1  # котрежная замена?????????

# 2.4 шаг 1
# преобразование типов
s = '1992'  # строка 1992
year = int(s)  # выводится как число 1992

num = int(input())  # чтобы вводимый текс считывался как число

print(3 * (a + b)**3 + 275 * b**2 - 127 * a - 41)  # Для возведения в степень используется **

# Поиск цифр в четырехзначном числе
# 2.5 Шаг 15
number = int(input())
a = number // 1000
b = (number % 1000) // 100
c = (number % 100) // 10
d = (number % 100) % 10
print(f'Цифра в позиции тысяч равна {a}')
print(f'Цифра в позиции сотен равна {b}')
print(f'Цифра в позиции десятков равна {c}')
print(f'Цифра в позиции единиц равна {d}')

# 4.1 шаг 10, нахождение минмального числа из 4 чисел
a = int(input())
b = int(input())
c = int(input())
d = int(input())
if a < b:  # Сравниваю "a" и "b"
    a = a
else:
    a = b  # Найднный минимум записываю в "а"
if c < d:  # Сравниваю "c" и "d"
    c = c
else:
    c = d  # Найденный минимум пишу в "c"
if a < c:  # Сравниваю два минимума и вывоже найденный
    print(a)
else:
    print(c)

# 4.1 шаг 12
# Пример хорошего решенияб на вход программе подается три числа, нужно вывести сумму только положительных чисел
# Вместо перебора всех возможных комбинаций положительных/отрицательных чисел ввел отдельную переменную,
# куда записыал только положительные числа
a = int(input())
b = int(input())
c = int(input())
sum = 0  # Ввожу переменную счетчик, ставлю ее 0
if a > 0:
    sum = sum + a  # К переменной счетчику добавляю только положительные числа
if b > 0:
    sum = sum + b
if c > 0:
    sum = sum + c
print(sum)

# в первую очередь выполняется логическое отрицание not;
# далее выполняется логическое умножение and;
# далее выполняется логическое сложение or.

# 4.2 шаг 11
number = int(input())
if ((number % 7 == 0) or (number % 17 == 0)) and 1000 <= number <= 9999:  # Не забываем скобки
    print('YES')
else:
    print('NO')

# 4.2 шаг 15
# Король ходит по горизонтали, вертикали или диагонали на одну клетку
a = int(input())
b = int(input())
c = int(input())
d = int(input())
if (1 <= a <= 8) and (1 <= b <= 8) and (1 <= c <= 8) and (1 <= d <= 8):
    if ((c - a == 1 or c - a == -1) and b == d) or ((d - b == 1 or d - b == -1) and a == c) or ((c - a == 1 or c - a == -1) and (d - b == 1 or d - b == -1)):
        print('YES')
    else:
        print('NO')
else:
    print('NO')

# 4.3 шаг 8
# Вводится два числа и третий оператор - отображает математическую операцию
a = int(input())
b = int(input())
c = input()
if c == '/' and b != 0:
    print(a / b)
elif c == '/' and b == 0:
    print('На ноль делить нельзя!')
elif c == '+':
    print(a + b)
elif c == '-':
    print(a - b)
elif c == '*':
    print(a * b)
else:
    print('Неверная операция')

# 4.3 шаг 9
# Задача на смешивание двух цветов
colour_1 = input()
colour_2 = input()
if (colour_1 == 'красный' or colour_1 == 'синий' or colour_1 == 'желтый') and (colour_2 == 'красный' or colour_2 == 'синий' or colour_2 == 'желтый') and colour_1 != colour_2:
    if colour_1 == 'красный' or colour_2 == 'красный':
        if colour_2 == 'желтый' or colour_1 == 'желтый':
            print('оранжевый')
        elif colour_2 == 'синий' or colour_1 == 'синий':
            print('фиолетовый')
    elif colour_1 == 'синий' or colour_2 == 'синий':
        if colour_2 == 'желтый' or colour_1 == 'желтый':
            print('зеленый')
elif colour_1 == colour_2 and (colour_1 == 'красный' or colour_1 == 'синий' or colour_1 == 'желтый') and (colour_2 == 'красный' or colour_2 == 'синий' or colour_2 == 'желтый'):
        print(colour_1)
else:
    print('ошибка цвета')

num1 = 25_000_000  # выведет 25000000
num2 = 25000000  # выведет 25000000

a = int(input())
b = int(input())
c = int(input())
print(max(a, b, c), min(a, b, c))  # встроенные метода min() max() для нахождения минимума и максимума

a = int(input())
print(abs(a))  # abs() встроенный метод для нахождения модуля числа

# 6.1 шаг 14
# интересным, если в нем разность максимальной и минимальной цифры равняется средней по величине цифре (дается трехзначное число)
num = int(input())
first = num // 100
second = num % 100 // 10
third = num % 10
avg = first + second + third - max(first, second, third) - min(first, second, third)
if max(first, second, third) - min(first, second, third) == avg:
    print('Число интересное')
else:
    print('Число неинтересное')

# 6.2 шаг 8
# ключ key в min() max()
city1 = input()
city2 = input()
city3 = input()
print(min(city1, city2, city3, key=len))  # в min() и max() можно включить атрибут key= чтобы указать, как будет проходить сравнение
print(max(city1, city2, city3, key=len))

# Пример хорошего решения, не мой
# Пример множественного присваивания переменных и сепарации строк с переходом на следующую строку (sep='\n')
a, b, c = input(), input(), input()

if(len(a) < len(b)): b, a = a, b
if(len(c) > len(b)): c, b = b, c
if(len(c) > len(a)): c, a = a, c

print(c, a, sep='\n')

# 6.2 шаг 10
# оператор in
s = input()
if 'a' in s:
    print('Введенная строка содержит символ а')
else:
    print('Введенная строка не содержит символ а')

# Конструкция in
a = input()
if 'суббота' in a or 'воскресенье' in a:  # Конструкция '1' or '2' in a непрвильно, правльно '1' in a or '2' in a
    print('YES')
else:
    print('NO')

# ИМПОРТ МОДУЛЕЙ
import math  # для вызова метода из модуля: math math.methodName()
from math import *  # иморт всех методов из библиотеки math, тогда можно вызывать все методы этого модуля так: methodName()
from math import sqrt, ceil  # Для вызова конретных методов из math, тогда указанные методвы вызываются так: methoName()

# 6.3 шаг 3
import math
a = float(input())
print(math.pi * math.pow(a, 2), 2 * math.pi * a, sep='\n')  # Используем импортированный pi и метод pow(x, n) возведение x в степень n

# 6.3 шаг 8
# Пример использования разных методов из math
import math
n = int(input())
a = float(input())
s = float((n * a**2)/(4 * math.tan(math.pi/n)))
print(s)

# 7.1 шаг 3
# цикл for - стрктура
a = input()
b = int(input())
for i in range (b):  # for название_переменной_цикла in range(количество повторений):
    print(a)  # блок кода

# 7.2 шаг 8
# Задание интервала действия цикла
n = int(input())
for i in range (0, n+1): # Интервал указывается как (x, y, z), где y, z - не обязательные. x - начало цикла, y - конец цикла, z - шаг цикла
    print(f'Квадрат числа {i} равен {i**2}')

# 7.1 шаг 10
#
m = int(input())  # кол-во организмов в начале
p = int(input())  # увелечение в процентах организмов ежедневно
n = int(input())  # кол-во дней
for i in range (0, n):  # Объявляю интервал цикла от 0 до указанного кол-ва дней
    if i == 0:  # в первый день указываю неизменной кол-во организмов
        print(i+1, m)
    else:
        res = float(m * (p/100 + 1))  # считаю результат в конкретный день
        print(i+1, res)
        m = res  # Указываю новое кол-во организмов в m (начальное число организмов)

# в range:
# первый параметр – это старт последовательности (включительно);
# второй параметр – это стоп последовательности (не включительно);
# третий параметр – это величина шага. (mustBeNotZero)

# 7.3 шаг 7
# Пример цикла, условия и импорт библиотеки
import math
n = int(input())
ans = 1
for i in range(2, n+1):
    if i < n:
        ans += 1/i
    elif i == n:
        ans = ans + 1/n - math.log(n)
print(ans)

# 7.3 шаг 10
# вывести произведение чисел отличных от 0, при вводе 10 чисел
mult = 1
for i in range(10):  # обозначаю кол-во повторений цикла (кол-во введенных чисел)
    n = int(input())  # при каждом повторении цикла записываю одно из десяти чисел в "n"
    if n != 0:  # сравниваю число с нулем
        mult *= n  # если не равно нулю, умножаю
print(mult)

# 7.3 шаг 15
# Вывести последовательность числе Фибоначчи
n = int(input())  # колличество чисел в последовтельности Фибоначчи
a = 1
b = 1
if n >= 3:
    for i in range(1, n):  # ввожу цикл от одного, n
        if i == 1:  # Если первый оборот цикла
            print(1, 1, end = ' ')  #то вывожу 1, 1, так как в фибоначи первые два числа считаются не так, как все последующе
        else:  # После первого оборота цикла начинаю считать последовательности
            c = a + b # Третий член последовательности складывается из двух предыдущих
            print(c, end=' ')  # Вывожу посчитанный член последовательности
            a, b = b, a + b  # чтобы посчитать следующий член последовательности после "c" передвигаю "a", "b" вперед на один член последовтельности, то есть присваиваю "a" значение "b", "b" присваиваю значение "c"
elif n == 2:
    print(1, 1)
elif n == 1:
    print(1)

# 7.4 шаг 10
# пример цикла while
text = input()  # подается текст
counter = 0  # задаю переменную счетчик
while text != 'стоп' and text != 'хватит' and text != 'достаточно':  # задаю цикл while с проверкой трех условий
    counter += 1  # Каждый раз, когда цикл проходит условия, прибавляю к счетчику 1
    text = input()  # в конце цикла меняю переменную text на новую введенную, чтобы двигаться дальше по циклу
print(counter)  # когда цикл завершен вывожу переменную счетчик

# 7.4 шаг 14
# вводится цена, существуют моенты номиналом 25 10 5 1, каким минимальным кол-вом моент можно покрыть эту цену, вывести кол-во моент
price = int(input())
counter = 0
while price > 0:
    if price // 25 != 0:
        counter += price // 25
        price = price - ((price // 25) * 25)
    elif price // 10 != 0 and price // 25 == 0:
        counter += price // 10
        price = price - ((price // 10) * 10)
    elif price // 5 != 0 and price // 25 == 0 and price // 10 == 0:
         counter += price // 5
         price = price - ((price // 5) * 5)
    elif price // 1 != 0 and price // 25 == 0 and price // 10 == 0 and price // 5 == 0:
         counter += price // 1
         price = price - ((price // 1) * 1)
print(counter)

# 7.5 шаг 5
# вывод цифр числа в обратном порядке
n = int(input())  # вводится натуральное число
while n != 0:  # пока n != 0 цикл выполняется
    ld = n % 10  # в переменную ld ввожу последнюю цифру чилса n
    print(ld, end='')  # вывожу на экран переменную ld, не переходя на следующую строку (если не указывать не переход на след строку, то это происходит автоматически)
    n = n // 10  # перед следующим стратом цикла от числа n убираем цифру и заново начинаем цикл, повторяя шаги

# 7.5 шаг 6
# Программа должна вывести максимальную и минимальную цифры введенного числа
# Решение 1
n = int(input())  # ввожу натрульное n
a = -1  # ввожу переменную, где будет максимум
b = 10  # ввожу переменную, где будет минимум
while n != 0:  # Объявляю цикл пока n не станет равным нулю
    num = n % 10   # в nu, записываю последнюю цифру
    if num > a:  # если последняя цифра больше, чем переменная максимума
        a = num  # то меняю перменную максимум на эту цифру
    if num < b:  # если последняя цифра больше, чем переменная минимума
        b = num  # то меняю перменную минимума на эту цифру
    n = n // 10  # убираю последнюю цифру, по которой уже отработал цикл
print(f'Максимальная цифра равна {a}', f'Минимальная цифра равна {b}', sep='\n')  # вывожу найденный максимум и найденный минимум, разделяя их переходом строки
# Решение 2 (короче но не такое прозрачное, как решение 1)
n = input()  # получаю натуральное число, как str()
print(f'Максимальная цифра равна {max(n)}', f'Минимальная цифра равна {min(n)}', sep='\n')  # нахожу максимум из строки n (сравнения по значению цифр в строке), так - же нахоже минимум

# 7.5 шаг 7
# Пример работы с числом
n = int(input())  # ввожу натрульное n
n1 = n  # Копирую введенное изначально число в переменную n1
summ = 0  # Объявляю переменную, в которой будет суммы цифр
mult = 1  # Объявляю переменную, в которой будет произведение цифр
counter = 0  # Объявляю переменную, в которой будет кол-во цифр
last_digit = n % 10  # Нахожу последнюю цифру числа
while n != 0:  # Объявляю цикл пока n не станет равным нулю
    summ += n % 10  # в сумме складываю цифры числа n, начиная с последней
    mult *= n % 10  # в произведении перемножаю цифры числа n, начиная с последней
    counter += 1  # при каждом обороте цикла прибавляю к переменной - счетчику 1
    n = n // 10  # пройдя цикл по последней цифре числа n удаляю последнюю цифру числа n и начинаю цикл заново, пока "n" не ноль
for i in range (1, counter):  # Обявляю цикл от 1 до кол-ва цифр в числе (получено в предыдущем цикле)
    n1 = n1 // 10 # так - как n равно 0 после предыдущего цикла, использую копию (n1), так - же отрезаю последнюю цифру при каждом обороте цикла
    if i == counter - 1:  # если оборот цикла остался на первой цифре (условия соблюдено при counter - 1, если использовать i == counter получим n1 == first... == 0
        first_digit = n1  # объявляюю переменную, в которой будет первая цифра
print(summ, counter, mult, summ / counter, first_digit, first_digit + last_digit, sep='\n')  # вывожу на печать все полученные значения, разделяя переводом строки

# 7.5 шаг 9
# Являются ли все цифры в числе одинаковыми
n = int(input())  # ввожу натуральное n
same = True  # создаю флаг и присваиваю ему True
prev = n % 10  # объявляю переменную prev и даю ей значение последней цифры числа "n"
while n != 0:  # объявляю цикл, окончивающийся на n == 0
    dig = n % 10  # в начале цикла записываю в dig последнюю цифру
    if dig != prev:  # если dig != prev (после первого прохода цикла: сравнивается цифра числа с его следующей цифрой)
        same = False  # флаг same менятеся на False () при выполнении условия (если соседние цифры не равны)
    prev = dig  # в prev записывается dig (получается, что при следующем проходе цикла и сравнении dig и prev, в prev останется удаленная из числа цифра, а в dig следующая после удаленной)
    n = n // 10  # убираем последнюю цифру числа n, таким образом двигаемся по числу начиная с послденей цифры и удаляя пройденные цифры
if same is True:  # итоговое сранение флага, если флаг изменился на False, то выводим  NO по условию задачи
    print('YES')
else:
    print('NO')

# 7.6 шаг 1 пример остановки цикла
# Оператор break прерывает ближайший цикл for или while
# В подобных случаях, когда существует множество причин завершения цикла,
# часто их проще выделить из нескольких разных мест, чем пытаться указать все условия завершения в заголовке цикла.
while True:  # бесконечный цикл
    if условие 1:  # условие для остановки цикла
        break
    ...
    if условие 2:  # еще одно условие для остановки цикла
        break
    ...
    if условие 3:  # еще одно условие для остановки цикла
        break
# бесконечные циклы могут быть очень полезными. Просто помните,
# что вы должны убедиться, что цикл в какой-то момент будет прерван, чтобы он действительно не становился бесконечным.

# Оператор continue позволяет перейти к следующей итерации цикла for или while до завершения всех команд в теле цикла.
# Напишем программу, которая выводит все числа от 1 до 100, кроме чисел 7, 17, 29 и 78.
for i in range(1, 101):
    if i == 7 or i == 17 or i == 29 or i == 78:
        continue  # переходим на следующую итерацию
    print(i)

# 7.6 шаг 7
# пример прерывания цикла break
# нахождение наименьшего делителя
n = int(input())
for i in range(2, n + 1):
    if n % i == 0:
        print(i)
        break # после нахождения первого делителя заканичваю цикл for оператором break

# Пример использование continue
n = int(input())
for i in range(1, n + 1):
    if  5 <= i <= 9 or 17 <= i <= 37 or 78 <= i <= 87:
        continue  # если произошло соответствие по условию - то происходит переход на следующую итерацию цикла
    print(i)

# 7.6 шаг 9
# else в циклах (while, for)
num = int(input())
n = num
while n != 0:
    last = n % 10
    if last == 7:
        print('Число', num, 'содержит цифру 7')
        break
    n //= 10
else:  # Если цикл закончил работу штатным образом (не через break), то выполняется условие else
    print('Число', num, 'не содержит цифру 7')


# 7.8 шаг 7
# таблицу сложения для всех чисел от 11 до nn
n = int(input()) # Вводится натрульное n
for i in range(1, n + 1):  # беру диапозон от 1 до n включительно
    for j in range(1, 10):  # для каждого числа из дипозона от 1 до n включительно выполняю цикл 9 раз
                print(f'{i} + {j} = {i + j}')  # прибавляю к каждой итерации i все итерации j, получается таблица сложения
    print()  # ставлю пробел после каждой итерации цикла i

# 7.8 шаг 8
# Напишите программу, которая печатает равнобедренный звездный треугольник с основанием, равным nn
n = int(input())  # Вводится натрульное n
for i in range(1, (n + 1) // 2 + 1):  # сначала строю от начала основания до середины, вычисляя серидину основания через прибавления 1 к n и делению на два
    print('*' * i)  # строю часть треугольника до середина основания включительно, половина готова
for i in range((n + 1) // 2 -1, 0, -1):  # чтобы достроить вторую половину, беру интервал от середины основания до конца основания
    print(i * '*')  # вторая часть треугольника готова (второй цикл работает так - же как первый, но на убывание)


n = 5
counter = 1
for i in range(1, n + 1):  # обозначаю, что высота треугольника, который будет построен - это "n", то есть мы 5 раз повторим цикл
    for j in range(i):  # для каждой строки повторяем цикл i раз, то есть на каждой строке будет столько выводов, какая итерация внешнего цикла это по счету
        print(counter, end=' ')  # вывожу counter, который подсчитывает кол - во итерация внутриннего цикла столько раз, какая по счету это итерация внешнего цикла
        counter+=1  # прибавляю один, чтобы каждый сделать лесенку из по возрастанию цифр
    print()  # вывожу пустую строку после последнего вывода counter (так как у него end=' ', то строка после него не перейдет на следующую), чтобы каждая ступенька лесенки с высотой n выводилась на новой строке, иначе это будет одна длинная строка

# 7.9 шаг 3
# вывести на промежутке от [a:b] число с максимальной суммой делителей, вывести сумму делителей и число
a = int(input())
b = int(input())
num = -1
max = -1
for i in range(a, b + 1):  # выставляю внешний цикл от [a:b]
    summ = 0  # в начале каждой итерации внешнего цикла (при входе каждого нового числа из промежутка) выставляю сумму делителей = 0
    for j in range(1, i+1):  # ищу делители на промежутке от 1 до вошедшего в итерации числа
        if i % j == 0:  # если найден делитель числа
            summ += j  # прибавляю его к сумме делителей
    if max <= summ: # после прохождения по всем возможным делителям сравниваю сумму делителей вошедшего в цикл числа с имеющимся максимумом, если максимум меньше найденной суммы, важно что стоит именно <=, а не <, чтобы при одинаковой сумме делителей у двух чисел выводилось наибольшее
        max = summ  # записываю в максимум полученную в предыдущем цикле сумму
        num = i  # запоминаю вошедшее в цикл число, чтобы запомнить, у какого числа максимальная сумма делителей
print(num, max) # вывожу найденное макс число и его сумму делителей на печать

# 7.9 шаг 8
# вывести простые числа из промежутка [a: b] (делятся только на 1 и на себя)
a, b = int(input()), int(input())
for i in range(a, b + 1):   # выставляю внешний цикл от [a:b]
    flag = True  # по умолчанию считаю, что число просто при начале итерации
    for j in range(2, i):  # начинаю искать делите на промежутке от 2 до числа, которое вошло в цикл, не включительно
        if i % j == 0:  # если делитель найден
            flag = False  # то число не является простым
    if flag == True and i != 1:  # если по итогам итерации делителей не найдено и flag остался True, то вывожу это число на печать
        print(i)

# 8, экзамен
# перевод числоа в строку, чтобы обратиться к нужной по счету цифре, не знаю изначально длину числа
n = int(input())
for i in range(len(str(n)) - 3):
    n //= 10
print(n % 10)

# задача из экз
# числа Рамануджана
# Напишите программу, которая находит аналогичные интересные числа. В ответе запишите первые 5 чисел в порядке возрастания, включая число 17291729
for a in range(1, 34):
    for b in range(1, 34):
            for c in range(1,34):
                for d in range(1,34):
                    if c**3 + d**3 == a**3 + b**3:
                        if a != c and a != d and b != c and b != d:
                            print(a**3 + b**3)
# 9 строки
text = "Such a lovely place"
for index in range(len(text)): # чтобы пройти по всей строке целиком, получая индексы в строке
    print(text[index])  # обращение к конкретному индексу в строке

s = '123'
print(s[1])  # выведет 2, обращаемся к первому символу в строке, индексы начинаются с 0

text = 'abcdefgh'
for letter in text:  # переменной letter присваивается значения буквы из строки text, так - же проходит по всей строке, записывая каждый символ в переменную цикла
    print(letter)

s = '01234567891011121314151617'
for i in range(0, len(s), 5):
    print(s[i], end='')

# 9.1 шаг 13
# определяет сколько в ней одинаковых соседних символов.
s = input()
counter = 0
for i in range(len(s)):
    if s[i] == s[i - 1] and i != 0:  # проверка на i != нужна, чтобы при i == 0 не было сравнения с s[-1], то чтобы не было сравнения первого символа строки с последним
        counter += 1
print(counter)

# 9.1 шаг 14
s = input()
counter_1 = 0
counter_2 = 0
for i in s:
    if i.lower() in 'ауоыиэяюёе':  # чтобы не учитвать заглавные буквы отедльно, перевожу полученные буквы в нижний регистр
        counter_1 += 1
    elif i.lower() in 'бвгджзйклмнпрстфхцчшщ':  # чтобы не учитвать заглавные буквы отедльно, перевожу полученные буквы в нижний регистр
        counter_2 += 1
print(f'Количество гласных букв равно {counter_1}', f'Количество согласных букв равно {counter_2}', sep='\n')

# 9.2 шаг 1
#  В Python строки являются неизменяемыми, то есть мы не можем менять их содержимое с помощью индексатора.
#
# Если мы хотим поменять какой-либо символ строки s, мы должны создать новую строку. Следующий код использует срезы и решает поставленную задачу:
s = 'abcdefghij'
s = s[:4] + 'X' + s[5:]

# s[2:5] строка состоящая из символов с индексами 2, 3, 4
# s[:5]	первые пять символов строки
# s[5:]	строка состоящая из символов с индексами от 5 до конца
# s[-2:] последние два символа строки
# s[:]	вся строка целиком
# s[1:7:2]	строка состоящая из каждого второго символа с индексами от 1 до 6
# s[::-1]  jihgfedcba строка в обратном порядке, так как шаг отрицательный

# синтаксис среза
# [x:y:z] x - начало интервала, включительно y - конец интервала, невключительно, z - шаг (как в range())

s = input()
print(len(s))  # общее количество символов в строке;
print(s*3)  # исходную строку повторенную 3 раза;
print(s[0])  # первый символ строки;
print(s[0:3])  # первые три символа строки;
print(s[-3:])  # последние три символа строки;
print(s[::-1])  # строку в обратном порядке;
print(s[1:-1])  # строку с удаленным первым и последним символом.
print(s[2])  # третий символ этой строки;
print(s[-2])  # предпоследний символ этой строки;
print(s[:5])  # первые пять символов этой строки;
print(s[:-2])  # всю строку, кроме последних двух символов
print(s[::2])  # все символы с четными индексами;
print(s[1::2])  # все символы с нечетными индексами;
print(s[::-1])  # все символы в обратном порядке;
print(s[-1::-2])  # все символы строки через один в обратном порядке, начиная с последнего.

# 9.2 шаг 14
# подается строка, разрезать ее на две равные части, переставит их местами и вывести на экран.
s = input()
x = len(s)//2 + len(s) % 2  # получаю дину строки и если она нечетная, то прибавляю 1
first_half = s[:x]  # получаю первую половину от 0 до половину строки невключительно, то есть при длине 7 вывожу 1234 ([:4] 4 не включительно)
second_half = s[x:]  # получаю вторую половину от середины строки включительно до конца строки, то есть при длине 7 вывожу 567 ([4:] 4 включительно)
print(second_half + first_half)  # переставляю их местами и вывожу на экран

# МЕТОДЫ СТРОК
# Таким образом: метод — функция, применяемая к объекту. Метод вызывается в виде имя_объекта.имя_метода(параметры)

# Метод capitalize() возвращает копию строки s, в которой первый символ имеет верхний регистр, а все остальные символы имеют нижний регистр.

# Метод swapcase() возвращает копию строки s, в которой все символы, имеющие верхний регистр, преобразуются в символы нижнего регистра и наоборот.

# Метод title() возвращает копию строки s, в которой первый символ каждого слова переводится в верхний регистр.

# Метод lower() возвращает копию строки s, в которой все символы имеют нижний регистр.

# Метод upper() возвращает копию строки s, в которой все символы имеют верхний регистр.

# Метод count(<sub>, <start>, <end>) считает количество непересекающихся вхождений подстроки <sub> в исходную строку s. от <start> до <end>

# Метод startswith(<suffix>, <start>, <end>) определяет начинается ли исходная строка s подстрокой <suffix>.
#     Если исходная строка начинается с подстроки <suffix>,метод возвращает значение True, а если нет, то  False.

# Метод endswith(<suffix>, <start>, <end>) определяет оканчивается ли исходная строка s подстрокой <suffix>. Может получать список значений - s.endswith((<sub_0>, <sub_1>))
#     Метод возвращает значение True если исходная строка оканчивается на подстроку <suffix> и False в противном случае.

# Метод find(<sub>, <start>, <end>) находит индекс первого вхождения подстроки <sub> в исходной строке s.
#     Если строка s не содержит подстроки <sub>, то метод возвращает значение -1

# Метод rfind(<sub>, <start>, <end>) идентичен методу find(<sub>, <start>, <end>), за тем исключением, что он ищет первое вхождение подстроки <sub> начиная с конца строки s

# Метод strip() возвращает копию строки s у которой удалены все пробелы стоящие в начале и конце строки.

# Метод lstrip() возвращает копию строки s у которой удалены все пробелы стоящие в начале строки.

# Метод rstrip() возвращает копию строки s у которой удалены все пробелы стоящие в конце строки.

# Методы strip(), lstrip(), rstrip() могут принимать на вход опциональный аргумент<chars>. Необязательный аргумент <chars>– это строка, которая определяет набор символов для удаления.

# Метод replace(<old>, <new>) возвращает копию s со всеми вхождениями подстроки <old>, замененными на <new>. Может принимать аргумент <count>, определяющий кол-во замен
#    пример: s.replace('foo', 'grault', 2)

# Метод isalnum() определяет, состоит ли исходная строка из буквенно-цифровых символов.
#    Метод возвращает значение True если исходная строка является непустой и состоит только из буквенно-цифровых символов и False в противном случае.

# Метод isalpha() определяет, состоит ли исходная строка из буквенных символов.
#     Метод возвращает значение True если исходная строка является непустой и состоит только из буквенных символов и False в противном случае.

# Метод isdigit() определяет, состоит ли исходная строка только из цифровых символов.
#     Метод возвращает значение True если исходная строка является непустой и состоит только из цифровых символов и False в противном случае.

# Метод islower() определяет, являются ли все буквенные символы исходной строки строчными (имеют нижний регистр).
#     Метод возвращает значение True если все буквенные символы исходной строки являются строчными и False в противном случае. Все неалфавитные символы игнорируются!

# Метод isupper() определяет, являются ли все буквенные символы исходной строки заглавными (имеют верхний регистр).
#     Метод возвращает значение True если все буквенные символы исходной строки являются заглавными и False в противном случае. Все неалфавитные символы игнорируются!

# Метод isspace() определяет, состоит ли исходная строка только из пробельных символов.
#     Метод возвращает значение True если строка состоит только из пробельных символов и False в противном случае.

# Метод со строками 'x'.join('y') в строку 'y' добавляется строка 'x' как разделитель, можно использовать со списками

# Метод join() со списками 'x'.join(words) превращает список words в строку с разделителем 'x'

# Метод split() 'x'.split('y') создает из строки 'x' список, отеделяя элементы в строке 'x' между собой по условному разделителю 'y'. '10-5-1'.split('-') создаст список ['10', '5', '1']

# 9.4 шаг 13
s = input()
dict_of_count = {}  # объявляю пустой словарь
for i in s:  # начинаю цикл по всей строке
    dict_of_count.update({s.count(i): i})  # применяю метод словаря .update() синтаксис -   my_dict.update({'another_key': 'another_value'})
print((max(dict_of_count.items())[1]))  # вывожу первый элемент из словаря, получаю список элементов через .items()

# 9.4 шаг 15
# вывести строку до первого выхождения 'h' и после последнего вхождения 'h'
s = input()
print(s[0:s.find('h')], s[s.rfind('h')+1:], sep='')  # в указании интервало использую строчный метод find и rfind

# 9.5 шаг 6
# Метод .format()
age = 27
name = 'Timur'
prof = 'math teacher'
txt = 'My name is {0}, I am {1}, I work as a {2}'.format(name, age, prof)  # в строке указываются {} - заполнители, на место которых встает name, age, prof
print(txt)

# 9.5 шаг 6
# f строки
first_name = 'Timur'
last_name = 'Guev'
age = 27
profession = 'math teacher'
affiliation = 'BeeGeek'
print(f'Hello, {first_name} {last_name}. You are {age}. You are a {profession}. You were a member of {affiliation}')  # при использовании f строк в заполнители можно вписывать переменные или выражение

# 9.6 шаг 5
# представление строки в виде кодов юникод (UTF)
s = input()  # получаю строку
for i in s:  # ввыожу цикл на всю строку
    print(ord(i), end=' ')  # каждый символ (i) перевожу в номер в кодировке юникод



# Работа со спискамм

#Оператор in в списках
numbers = [2, 4, 6, 8, 10]

if 2 in numbers:
    print('Список numbers содержит число 2')
else:
    print('Список numbers не содержит число 2')


# встроенная фнукция len() для списков
numbers = [2, 4, 6, 8, 10]
languages = ['Python', 'C#', 'C++', 'Java']


print(len(numbers))  # выводим длину списка numbers
print(len(languages))  # выводим длину списка languages


# в списках, как и встроках можно использовать срезы
print(numbers[1:3])
print(numbers[2:5])


# срезы списков можно использовать для изменения элементов в этом диапозоне
fruits = ['apple', 'apricot', 'banana', 'cherry', 'kiwi', 'lemon', 'mango']
fruits[2:5] = ['банан', 'вишня', 'киви']
# fruits = ['apple', 'apricot', 'банан', 'вишня', 'киви', 'lemon', 'mango'] новое значение списка


# конкатенация и умножение списков
print([1, 2, 3, 4] + [5, 6, 7, 8])  #  выводит [1, 2, 3, 4, 5, 6, 7, 8]
print([7, 8] * 3)  # выводит [7, 8, 7, 8, 7, 8]
print([0] * 10)  # выводит [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]


# встроенные функции sum(), min(), max() в списках
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print('Сумма всех элементов списка =', sum(numbers))  # sum() принимает в качестве параметра список чисел и вычисляет сумму его элементов.


numbers = [3, 4, 10, 3333, 12, -7, -5, 4]  # min() и max() принимают в качестве параметра список и находят минимальный и максимальный элементы соответственно.
print('Минимальный элемент =', min(numbers))
print('Максимальный элемент =', max(numbers))


# урок 11.2 шаг 8
# инвертировани есписка
lang = ['Chinese', 'Spanish', 'English', 'Hindi', 'Arabic', 'Bengali', 'Portuguese', 'Russian', 'Japanese', 'Lahnda']
lang.reverse()
print(lang)


# методы списков, встроенные функции
lst = [1, 2, 3]

lst.append(x)  # Добавляет элемент в конец списка <numbers.append(1)>

lst.extend(L)  # Расширяет список lst, добавляя в конец все элементы списка L <numbers.extend(odds)>, возвращает None

lst.insert(i, x)  # Вставляет на i-ый элемент значение x, расширяя список, сдвигая все элементы после вставленного элемента к концу списка

lst.remove(x)  # Удаляет первый элемент в списке, имеющий значение x. ValueError, если такого элемента не существует

lst.pop([i])  # Удаляет i-ый элемент и возвращает его. Если индекс не указан, удаляется и возвращается последний элемент

lst.index(x, [start [, end]])  # Возвращает положение первого элемента со значением x (при этом поиск ведется от start до end, отрезок указывать необязательно)

lst.count(x)  # Возвращает количество элементов со значением x

lst.sort([key=функция])  # Сортирует список на основе функции, возвращает None

sorted(lst) # если требуется сохранить исходный список -    a = [1, 3, 3]    b = sorted(a)

lst.reverse()  # Разворачивает список

lst.copy()  # Поверхностная копия списка

lst.clear()  # Очищает список

print(*lst) # раскрывает список по элементам

max(lst)  # максимум из списка

min(lst)  # минимум из списка

sum(lst)  # сумма элементов списка

list(reversed(lst))  # возвращает инвертированный (развернутый список)
# пример
seq_string = 'Python'
print(list(reversed(seq_string)))  # ['n', 'o', 'h', 't', 'y', 'P']

# Примечание
# Существует большая разница в работе строковых и списочных методов. Строковые методы не изменяют содержимого объекта к которому они применяются, а возвращают новое значение.
# Списочные методы, напротив, меняют содержимое объекта к которому применяются.

# Отличие между методами append() и extend() проявляется при добавлении строки к списку.
words1 = ['iq option', 'stepik', 'beegeek']
words2 = ['iq option', 'stepik', 'beegeek']
words1.append('python')
words2.extend('python')
print(words1)
print(words2)
# ['iq option', 'stepik', 'beegeek', 'python']
# ['iq option', 'stepik', 'beegeek', 'p', 'y', 't', 'h', 'o', 'n']
# Метод append() добавляет строку 'python' целиком к списку, а метод extend() разбивает строку 'python' на  символы 'p', 'y', 't', 'h', 'o', 'n' и их добавляет в качестве элементов списка.


# Оператор del можно удалять элементы списка по определенному индексу.
# Оператор del работает и со срезами: мы можем удалить целый диапазон элементов списка.
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
del numbers[2:7]    # удаляем элементы с 2 по 6 включительно, так - же можно указывать шаг в срезе [x:y:z]
print(numbers)
# [1, 2, 8, 9]


# 11.3 шаг 6
# пример работы со списками
numbers = [2, 6, 3, 14, 10, 4, 11, 16, 12, 5, 4, 16, 1, 0, 8, 16, 10, 10, 8, 5, 1, 11, 10, 10, 12, 0, 0, 6, 14, 8, 2, 12, 14, 5, 6, 12, 1, 2, 10, 14, 9, 1, 15, 1, 2, 14, 16, 6, 7, 5]
print(len(numbers))  # длина списка
print(numbers[-1])  # последний элемент списка
print(numbers[-1::-1])  # список в обратном порядке
if 5 in numbers and 17 in numbers:  # если 5 и 17 в списке
    print('YES')  #
else:  #
    print('NO')  #
print(numbers[1:-1])  # список без первого и последнего элемента


# 11.3 шаг 8
alphabet = 'abcdefghijklmnopqrstuvwxyz'
digits = []
for i in range(1, len(alphabet) + 1):
    digits.append(alphabet[i-1] * i)
print(digits)


# 11.3 шаг 9
# На вход программе подаются натуральное число nn, а затем nn целых чисел, каждое на отдельной строке. Программа должна вывести список, состоящий из кубов указанных чисел.
n = int(input())
numbers = []
for i in range(n):  # ввожу цикл в диапозоне n
    temp = int(input())  # в начале цикла записываю во временную переменную введенное значение
    numbers.append(temp**3)  # вставляю в конец списка с помощью .append() куб временной переменной
print(numbers)

# 11.3 шаг 11
# сумма двух соседних чисел и запись в список
n = int(input())  # кол-во чисел, которые будут введены
numbers = []
first = int(input())  # запоминаю первое число последовательности
for i in range(n-1):  # ввожу цикл на 1 меньше, чем кол-во чисел в последоватльности, потому, что за первую итерацию обработаю первые два числа, потом 2 и 3, потом 3 и 4, потом 4 и 5 - 4 итерации
    second = first  # записываю в переменнюу значение первого числа последовательности, чтобы потом сразу запомнить второе число в последовательности
    first = int(input())  # записываю новое значение в first, тем самы имею в переменных первое и второе число последовательности в этом шаге
    summafs = second + first  # складываю соседние числа
    numbers.append(summafs)  # кладу сумму соседних числе в список
print(numbers)
#  после каждой итерации в second кладется старое значение first, а в first кладется следующее число последоватльности, то есть сдвигаемся а 1 число вперед в последовательности

# 11.3 шаг 12
# удаление элементов из списка
n = int(input())
numbers = []
for i in range(n):  # ввожу цикл для создания списка длинной в n элементов
    temp = int(input())
    numbers.append(temp)
del numbers[1::2]  # удаляю элементы списка с нечетными индексами
print(numbers)

# 11.3 шаг 13
# k-ая буква слова, на вход подает n строк и в конце "k" - номер символа, который надо вывести из кажой строки
n = int(input())  # кол - во стро которое программа получит на вход
s = []  # создаю пустой цикл, элементы которого - будут n строк, которые программа получит
for i in range(n):  # ввожу цикл в диапозоне n, чтобы считать все строки и получить список, элементами которго будут эти строки
    temp = input()  # получаю на вход строку
    s.append(temp)  # вставляю полученную строку в конец списка, повторяю цикл n раз
k = int(input())  # после завершения цикла получаю номер символа, который надо вывести из каждой строки
for i in range(n):  # ввожу цикл в диапозоне n, чтобы обработать все строки
    chars = list(s[i])  # создаю новый список из строчного элемента списка, обращаясь к записанным ранее в другой список строкам по индексу (т.к. элемент - строка(для списка, к которому обращаюсь))
    if k <= len(chars):  # если номер символа не выходит за диапозон самой строки начинаю цикл, в котором вывожу нужный символ строки на основании полученного ранее строчного элемента списка
        temp = chars[k-1]
        print(temp, end='')

# 11.3 шаг 14
# вывод несколько строк посимвольно, как элементы списка
n = int(input())
s = []
for i in range(n):
    temp = input()  # запоминаю введенную строку
    s.extend(temp)  # метод .extend() разбивает строку на элементы и добавляет каждый в список по отдельности
print(s)

# 11.4
# Вывод элементов списка без циклов "for i in (len(numbers)):" или "for i in numbers:"
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(*numbers)  # *lst раскрывает список по элементам

# 11.5 шаг 2
# вывести сумму квадратов всех элементов списка
numbers = [1, 78, 23, -65, 99, 9089, 34, -32, 0, -67, 1, 11, 111]
print(sum([i**2 for i in numbers]))  # хз што это

# 11.4 шаг 4
# удаление максимума и минимума из списка
n = int(input())
numbers = []
for i in range(n):
    temp = int(input())
    numbers.append(temp)
numbers.remove(max(numbers))  # lst.remove(x) - удаления превого вхождения x в lst, в этом случае нахожу max() встроенной функцией и удаляю его вхождение в список
numbers.remove(min(numbers))
print(*numbers, sep = '\n')


# 11.4 шаг 6
# поиск слова в списке и вывод всех совпадений, in списки
n = int(input())
ques = []
for i in range(n):
    temp = input()
    ques.append(temp)
request = input().lower()
for i in ques:
    if request in i.lower():
        print(i)

# 11.4 шаг 7
# На вход программе подается натуральное число nn, затем nn строк, затем число kk — количество поисковых запросов, затем kk строк — поисковые запросы.
# Напишите программу, которая выводит все введенные строки, в которых встречаются все поисковые запросы.
n = int(input())
s = []
requests = []
for i in range(n):
    temp = input()
    s.append(temp)
k = int(input())
for i in range(k):
    temp = input()
    requests.append(temp)  # Создаю два списка со строками и поисковыми запросами
for i in s:  # перебираю все элементы из списка строк
    flag = True  # по умолчанию считаю, что для каждой строки из списка встречается все осиковые запросы (список запросов)
    for j in requests:  # для взятого отедльного элемента списка строк начинаю перебирать все элементы списка запросов
        if j.lower() not in i.lower():  # если любой элемент списка запросов не попадает в элемент списка строки ставлю обновляю flag на False
            flag = False
    if flag is True: # после проверки каждого элемента списка строк запросов для одного элемента списка строк проверяю, какое значение имеет flag и вывожу строку, если True
        print(i)

# 11.5
# метод split() разбивает строку по произвольному разделителю на список
# У метода split() есть необязательный параметр, который определяет, какой набор символов будет использоваться в качестве разделителя между элементами списка.
# Например, вызов метода split('.') вернет список, полученный разделением исходной строки по символу '.'
# Пример
ip = '192.168.1.24'
numbers = ip.split('.')    # указываем явно разделитель
print(numbers)


# метод join() собирает строку из списка строк через заданный разделитель
# Пример
words = ['Python', 'is', 'the', 'most', 'powerful', 'language']
s = ' '.join(words)  # то, что указывается перед .join(lst) будет разделителем получившейся строки, то есть разделитель 123 - print('123'.join(words))
print(s)

# split() join() пример
s = input()  # получаю строку
p = s.split()  # создаю из строки список с помощью split, разделея эементы списка пробелом
print('\n'.join(p))  # преобразую созданный список в строку, разделяя слова переход строк \n


# 11.5 шаг 4
# Полдучаю на вход строку с именем отчеством и фамилией, нужно вывести инициалы через точку
s = input()  # получаю строку
fullName = s.split()   # создаю список из строки, каждое слово - элемент списка
fio_lst = []  # ввожу новый список, в который запишу все первые буквы (инициалы)
for i in range(len(fullName)):  # прохожусь по всем элементам списка, в котором у меня лежат ФИО
    fio_lst.append(fullName[i][0])  # использую двойную индексацию lst[номер элемента списка][номер символа в элементе списка], беру только первые буквы
fio_str = '.'.join(fio_lst)  # преобразую получившийся список с первыми буквами ФИО в строку, разделенную точками Ф.И.О
print(fio_str, end='.')  # Вывожу получившуюся строку с первыми буквами ФИО, не забывая про точку в конце

# 11.5 шаг 7
# Пример решения
s = input()
ip = [int(i) for i in s.split('.')]  # создаю список, в котором все элементы списка s.split('.') перевожу в int, применяя к каждой i, взятой из списка s.split('.') функцию int()
flag = True
for i in ip:
    if i > 255 or i < 0:
        flag = False
if flag is True:
    print('ДА')
else:
    print('НЕТ')


# 11.5 шаг 8
s = input()
s1 = input()
print(s1.join(s))  # строки можно джоинить друг к другу, где s1 - строка разделитель, а s - строка в которую разделитель будет вставлен (разделитель вставляется между всеми символами)

s = input()
counter = 0
numbers = [int(i) for i in s.split()]
for i in range (len(numbers)):
    for j in range(len(numbers[i + 1:])):
        if i == j:
            counter += 1
print(counter)


# 11.6 шаг 6
# заменить min и max в списке
s = input()
numbers = [int(i) for i in s.split()]  # обозначаю список
sMax = max(numbers)  # нахожу максимум списка
sMin = min(numbers) # нахожу минимум списка
sIndexOfMax = numbers.index(sMax)  # нахожу индекс максимума
sIndexOfMin = numbers.index(sMin)  # нахожу индекс минимума
numbers[sIndexOfMax], numbers[sIndexOfMin] = numbers[sIndexOfMin], numbers[sIndexOfMax]  # для списков так - же работает кортежное присваивание, то есть каждый элемент списка - это как отдельная переменная, к которой можно обращаться по индексу
print(*numbers)

# 11.6 шаг 7
# нахождение всех артиклей в строке
s = input()
message = s.split()  # создаю список из строки
articles = ['a', 'an', 'the']  # обозначаю список элементов, которые буду искать в списке, созданном из строки
counter = 0  # ввожу счетчик
for i in message:  # обозначаю цикл по всему списку строки
    if i.lower() in articles:  # к полученному элементу списка применяю lower, потому, что мой список с проверочными словами - в нижнем регистре
        counter += 1
print('Общее количество артиклей: {0}'.format(counter))  # вывожу общее кол - во артиклей через строчный метод .format()

# 11.6 шаг 11
# сортировка списков sort()
n = input()
numbers = n.split()  # создаю список из полученной строки
numbers = [int(i) for i in numbers] # ко всем элементам списка применяю функцию int()
numbers.sort()  # сортирую список
print(*numbers)  # вывожу отсортированный список по возрастанию
numbers.sort(reverse=True)  # сортирую список по убыванию
print(*numbers)  # вывожу отсортированный по убыванию список

# 11.7
# Списочные выражения, общий вид - [выражение for переменная in последовательность]
numbers = [i for i in range(10)]
chars = [c for c in 'abcdefg']

# Метод считывания строк, количество которых n
n = int(input())
lines = [input() for _ in range(n)]  # используем символ _ в качестве имени переменной цикла, поскольку она не используется.

# в списочных выражениях можно импользовать условный оператор
evens = [i for i in range(21) if i % 2 == 0]

# в списочных выражениях так - же можно использовать вложенные циклы
numbers = [i * j for i in range(1, 5) for j in range(2)]
# равнозначно
numbers = []
for i in range(1, 5):
    for j in range(2):
        numbers.append(i * j)
print(numbers)

# пример списочных выражений
word = 'Hello'
numbers = [1, 14, 5, 9, 12]
words = ['one', 'two', 'three', 'four', 'five', 'six']
firstLetter = [m[0] for m in words]  # ['o', 't', 't', 'f', 'f', 's']
numbersLessThan10 = [i for i in numbers if i < 10]  # 	[1, 5, 9]
wordsLenLessThan3 = [m[0] for m in words if len(m) == 3]  # ['o', 't', 's']


#  Создать новый список, удалив первый символ каждого элемента исходного списка
keywords = ['False', 'True', 'None', 'and', 'with', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'try', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'while', 'yield']
new_keywords = [i[1:] for i in keywords]  # использую срезы строки
print(new_keywords)

# 11.7 шаг
# Получение списка чисел из строки и вывод
s = input()
numbers = [int(i)**3 for i in s.split()]  # использую списочное выражение в последоватлеьности s.split(), перевожу каждый эелемент в куб
print(*numbers)

# 11.7 шаг 10
# вывод всех цифровых элементов строки
[print(i, end='') for i in input() if i.isdigit()]  # вывожу каждое i из введенной строки input(), прошедшего условный оператор

# 11.7 шаг 11
# На вход программе подается строка текста, содержащая целые числа.
# Напишите программу, использующую списочное выражение, которая выведет квадраты четных чисел, которые не оканчиваются на цифру 44.
[print(int(i)**2, end = ' ') for i in input().split() if int(i) % 2 == 0 and int(i)**2 % 10 != 4]

# 11.7 шаг 9
# пробелы можно заменять на перехол строки
print(input().replace(' ', '\n'))

# 12.1
# сложение списков
numbers1 = [1, 2, 3]
numbers2 = [10, 20, 30]
numbers3 = numbers1 + numbers2  # два списка можно сложить и вывести третий список в формте lst3 = [lst1, lst2]
print(numbers3)

# 12.2 шаг 2
# сумма соответствующих элементов двух списков
# сложить элементы с одинаковыми индексами в двух списках и положить в третий список
L = [int(i) for i in input().split()]
M = [int(i) for i in input().split()]
fin = [L[i] + M[i] for i in range(len(L))]
print(*fin)


# 12.2
# конкатенация строк из экзамена
s = input()
new = [i[1:] + i[0] + 'ки' for i in s.split()]  # удаляю первую букву каждого элемента, ставлю ее в конец, потом прибавляю слог 'ки', использую срезы и конкатенацию строк
print(*new)



# ФУНКЦИИ

# фукнция заглушка - пропускается ключевым словом pass. Используется там, где код еще не появился, но планируется
def do_nothing():
    pass

# Аргумент – это любая порция данных, которая передается в функцию, когда функция вызывается. Параметр – это переменная, которая получает аргумент, переданный в функцию.
# Локальными называются переменные, объявленные внутри функции и доступные только ей самой. Программный код за пределами функции к ним доступа не имеет.
# Для доступа к глобальным переменным внутри функции используется ключевое слово global, так - же для создания глобальных переменных можно использовать global
# Если глобальная переменная не объявляется с использованием ключевого слова global внутри функции, то присвоенное ей значение невозможно изменить внутри этой функции.
# К глобальным переменным можно обращаться внутри функции без ключевого слова global, но нельзя изменять

#  напчеатать равнобердренный треугольник из символов fill, с основанием base, используяю функцию с параметрами fill и base
def draw_triangle(fill, base):
    for i in range(1, (base + 1) // 2):
        print(fill * i)
    for i in range((base + 1) // 2, 0, -1):
        print(fill * i)
fill = input()
base = int(input())
draw_triangle(fill, base)

# Для доступа к глобальным переменным внутри функции используется ключевое слово global
# выдаст ошибку
c = 1  # глобальная переменная
def add():
    c = c + 2  # используем переменную 'c' до ее объявления
    print(c)
add()  # выдаст ошибку

# не выдаст ошибку
c = 2 # глобальная переменная
def add():
    global c  # получаем глобальную переменную 'c', использую global
    c = c + 2 # прибавляем 2 к c
    print("Внутри функции add():", c)
add()


# 13.3 шаг 9
# Объявление глобальное переменной с помощью global
def print_texas():
    global birds  # с помощью global можно объявить глобальную перменную, если такой нет
    birds = 5000
    print('В Техасе обитает', birds, 'птиц.')

def print_california():
    print('В Калифорнии обитает', birds, 'птиц.')

print_texas()
print_california()


# Пример global
x = 5
def add():
    global x  # вызываю глобальную переменную 'x'
    x = 3  # присваиваю глобальной переменной значение 3
    x = x + 5  # присваиваю глобальной переменной значение выражения
    print(x)
add()  # выведет 8 из функции
print(x)  # выведет 8, так - как в функции мы изменяли глобальную переменную


# 13.4 шаг 8
# поулчить список всех делителей числа
def get_factors(num):  # функция, которая возвращает список со всеми делителями числа
    diliteli = [int(i) for i in range(1, num // 2 + 1) if n % int(i) == 0]  # создаю список, в котором ищу все делители, кроме самомго числа
    diliteli.append(num)  # прибалвяю в конец списка делителей само число, так как оно тоже делитель, далее возвращаю список делителей
    return diliteli
n = int(input())  # получаю число, список делителей, которого нужно вывести
print(get_factors(n))  # передаю число в функцию, как аргумент num


# 13.4 шаг 10
# поулчить список всех индексов одого символа в строке
def find_all(target, symbol): # найти
    allSymbols = [int(i) for i in range(len(target)) if target[i] == symbol]  # прохожусь по всей строке, и если взятый из строки символ равен искомому символу записываю его индекс в список
    return  allSymbols  # возвращаю список индексов
s = input()
char = input()
print(find_all(s, char))  # передаю введеные s, char как аргументы функции


# 13.4 шаг 11
# сложить два списка и отсортировать
def merge(list1, list2):  # получаю два списка ка аргументы
    list3 = list1 + list2  # делаю третий список, конкатенацией двух других (нельяз использовать extend() так как возвращает none, изменяя список
    return list3  # возвращаю новый список, нельзя использовать тут sort, так как он вернет None
numbers1 = [int(c) for c in input().split()]
numbers2 = [int(c) for c in input().split()]
print(sorted(merge(numbers1, numbers2)))  # сортирую список на выводе (отсортировать так - же можно в функции, добавив еще одну строку, где сортируем полученной список)


#  13.5 шаг 1
# проверка введенного значения на валидность
def is_invalid(model):  # создаю функцию, в которой проверяю, не валидно ли число, если это так - True
    if model not in [100, 200, 300]:
        return True
    else:
        return False
model = int(input())  # получаю значение
while is_invalid(model) is True:  # пока из функции возвращается True (число невалидно), получаю новое значение и снова запускаю проверку на валидность
    print('Допустимыми номерами моделей являются 100, 200 и 300.')
    model = int(input())
print('Номер модели: {0}'.format(model))


# 13.5 шаг 4
# программа принимает num, должна вывести ближайшее большее простое число
def is_prime(num):
    counter = [int(i) for i in range(1, num + 1) if num % i == 0]  # записываю все делители полученного числа в список
    if len(counter) == 2:  # если делителей два возврщаю True (число простое), иначен False
        return True
    else:
        return False

def get_next_prime(num):  # функция, которая принимает num
    num += 1  # переходит сразу к большему числу
    while is_prime(num) is False:  # вызывает проврку числа на "простое"
        num += 1  # если оно не простое - увеличиваю число
    return num  # при нахождении простого возвращается число, которое прошло проверку на "простоту"

n = int(input())

print(get_next_prime(n))


# 13.5 шаг 5
# проверка введеного пароля на условия
# его длина не менее 8 символов;
# он содержит как минимум одну заглавную букву (верхний регистр);
# он содержит как минимум одну строчную букву (нижний регистр);
# он содержит хотя бы одну цифру.
def is_password_good(password):
    if len(password) < 8:  # его длина не менее 8 символов;
        return False
    for i in password:
        flagIsUpper = False  # он содержит как минимум одну заглавную букву (верхний регистр);
        if i.isalpha():  # isalpha() возвращает True - тогда условия проходит, иначе if не запускается
            if i.isupper():
                flagIsUpper = True
                break
    for i in password:
        flagIsDigit = False  # он содержит хотя бы одну цифру.
        if i.isdigit():  # isdigit() возвращает True - тогда условия проходит, иначе if не запускается
            flagIsDigit = True
            break
    for i in password:
        flagIsLower = False  # # он содержит как минимум одну строчную букву (нижний регистр);
        if i.isalpha():  # isdigit() возвращает True - тогда условия проходит, иначе if не запускается
            if i.islower():
                flagIsLower = True
                break
    if flagIsUpper is True and flagIsDigit is True and flagIsLower is True:
        return True
    else:
        return False

txt = input()

print(is_password_good(txt))




# 13.5 шаг 7
# два примера решения задачи на проверку, является ли введенный текст - палиндромом
# Пример 1
def is_palindrome(text):
    textOnlyLetters = [i for i in text.lower() if i.isalpha()]
    if textOnlyLetters == list(reversed(textOnlyLetters)):
        return True
    else:
        return False
txt = input()
print(is_palindrome(txt))


# Пример 2
def is_palindrome(text):
    textOnlyLetters = [i for i in text.lower() if i.isalpha()]
    ''.join(textOnlyLetters)
    if textOnlyLetters == textOnlyLetters[::-1]:
        return True
    else:
        return False
txt = input()
print(is_palindrome(txt))


# 13.5 шаг 8
# Проверка введёной строки на палиндром, простое число и четное число
def is_valid_password(password):
    flag = True
    elementsOfPassword = password.split(':')
    if len(elementsOfPassword) == 3  # если введенных числа 3 - запускаю проверки
        if str(elementsOfPassword[0]) != str(elementsOfPassword[0])[::-1]:  # проверка на полиндром (читается в обратном порядке так - же)
            return False
        if len([i for i in range(1, int(elementsOfPassword[1])//2) if int(elementsOfPassword[1]) % i == 0]) != 1:  # проверка на просто число, создавая список со всеми делителями, кроме самого число
            return False
        if int(elementsOfPassword[2]) % 2 != 0:  # проверка число на простое
            return False
    else:
        return False
    return flag
# считываем данные
psw = input()
# вызываем функцию
print(is_valid_password(psw))

# 13.5 шаг 10
# поменять "верблюжий" регистр на "змеиный"
def convert_to_python_case(text):
    for i in text:  # проверяю каждый полученной символ строки
        if i.isupper():  # если нахожу символ в верхнем регистре
            text = text.replace(i, '_' + i.lower())  # в исходной строке заменяю найденный символ на '_'+найденный символ
    return text[1:]  # вывожу строку без первого символа, потому, что первый символ будет _
# считываем данные
txt = input()
# вызываем функцию
print(convert_to_python_case(txt))



# работа со split() и join()
# split() и join() возвращают список/строку соответственно, но не преобразовывают исходный список/строку в новый формат
# то есть если ввести text.split() строка text так и останется строкой, но метод .split() вернет список, созданный из строки text
text = '123.123.123'
lst = ['1', '2', '3']
textLst = text.split('.')
lstConvert = ' '.join(lst)
print(textLst, lstConvert, sep = '\n')


# 14.1 шаг 10
# интересная задачка из экзамена
#  принимает в качестве аргумента строку текста на английском языке и возвращает значение True если текст является панграммой и False в противном случае.
def is_pangram(text):
    alph = [i for i in 'abcdefghijklmnopqrstuvwxyz']
    textLst = [i.lower() for i in set(text) if i.isalpha()]  # функция set() принимает строку и возвращает неповторяющиеся символы из строки
    for i in alph:
        if i not in textLst:
            return False
    return True
text = input()
print(is_pangram(text))

# Модуль random
# модуль 15
random.radint(a, b)  # принимает два обязательных аргумента a и b и возвращает число из отрезка a b включительно, и возвращает
random.randrange(a, b)  # Принимает a, b и возвращает из отрезка от a до b не включительно (работает как range()),
random.random()  # возвращает случайное число с плавающей точкой от 0 до 1 включительно
random.uniform(1.1, 12.3)  # возвращает случайно число с плавающей точкой в диапазоне
random.shuffle([1, 2, 3])  # принимает в качестве аргумента список и перемешивает его случайным образом
random.choice([1, 2, 3])  # принимает список (или строку) и возвращает случайный элемент
random.sample([1, 2, 3], 2)  # принимает список (строку) и количество элементов. возвращает список случайных элементов в указанном кол-ве

# шифр цезаря 2.0
def cesarCode():
    engAlph = 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz'
    engAlphUpper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ'
    rusAlph = 'абвгдежзийклмнопрстуфхцчшщъыьэюяабвгдежзийклмнопрстуфхцчшщъыьэюя'
    rusAlphUpper = 'АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ'
    text = input('Введите исходный текст')
    codeOrDecode = input('Введите, что требуется сделать, 1 - кодировать, 2 - декодировать')
    lang = input('Введите язык исходного текста rus/eng')
    key = int(input('Введите ключ шифра'))
    while isCesarKeysValid(codeOrDecode, lang, key) is False:
        cesarCode()
    fin = ''
    if lang == 'rus':
        if codeOrDecode == '1':
            for i in text:
                if i.isalpha():
                    if i.isupper():
                        fin += rusAlphUpper[rusAlphUpper.find(i) + key]
                    else:
                        fin += rusAlph[rusAlph.find(i) + key]
                else:
                    fin += i
        elif codeOrDecode == '2':
            for i in text:
                if i.isalpha():
                    if i.isupper():
                        fin += rusAlphUpper[rusAlphUpper.find(i) - key]
                    else:
                        fin += rusAlph[rusAlph.find(i) - key]
                else:
                    fin += i
    elif lang == 'eng':
        if codeOrDecode == '1':
            for i in text:
                if i.isalpha():
                    if i.isupper():
                        fin += engAlphUpper[engAlphUpper.find(i) + key]
                    else:
                        fin += engAlph[engAlph.find(i) + key]
                else:
                    fin += i
        elif codeOrDecode == '2':
            for i in text:
                if i.isalpha():
                    if i.isupper():
                        fin += engAlphUpper[engAlphUpper.find(i) - key]
                    else:
                        fin += engAlph[engAlph.find(i) - key]
                else:
                    fin += i
    engAlphUpper
    print(fin)

def isCesarKeysValid(codeOrDecode, lang, key):
    if codeOrDecode not in ['1', '2']:
        print('Значение кодировать или декодировать', end='')
        return False
    if lang not in ['eng', 'rus']:
        print('Язык кодировки', end='')
        return False


# интересная задачка из курса
# Ключ шифра по отдельности использовать для каждого слова - длина слова - ключ шифра
# Каждое слово строки следует зашифровать с помощью шифра Цезаря
# Строчные буквы при этом остаются строчными, а прописные – прописными.
def dlina(word):
    s = [i for i in word if i.isalpha()]
    return len(s)

engAlph = 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz'
engAlphUpper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ'
fin = ''
text = input()
for i in text.split():
    key = dlina(i)
    for k in i:
        if k.isalpha():
            if k.isupper():
                fin += engAlphUpper[engAlphUpper.find(k) + key]
            else:
                fin += engAlph[engAlph.find(k) + key]
        else:
            fin += k
    fin += ' '
print(fin)


# модуль math
int()  #Округляет число в сторону нуля
round(x)  #Округляет число x до ближайшего целого. Если дробная часть числа равна 0.5, то число округляется до ближайшего четного числа
round(x, n)  #Округляет число x до n знаков после точки
floor(x)  #Округляет число x вниз («пол»)
ceil(x)  #Округляет число x вверх («потолок»)
abs(x)  #Модуль числа x (абсолютная величина)
# Корни, логарифмы, степени и факториал
sqrt(x)  #Квадратный корень числа x
pow(x, n)  #Возведение числа x в степень n
log(x)  #Натуральный логарифм числа x. Основание натурального логарифма равно числу e
log10(x)  #Десятичный логарифм числа x. Основание десятичного логарифма равно числу 10
log(x, b)  #Логарифм числа x по основанию b
factorial(n)  #Факториал натурального числа n
# Тригонометрия
degrees(x)  # Преобразует угол x, заданный в радианах, в градусы
radians(x)  #Преобразует угол x, заданный в градусах, в радианы
cos(x)  #Косинус угла x, задаваемого в радианах
sin(x)  #Синус угла x, задаваемого в радианах
tan(x)  #Тангенс угла x, задаваемого в радианах
math.pi # число пи


import datetime


def test():
    return datetime.date.today().replace(day=1), datetime.date.today().replace(day=1) + datetime.timedelta(minutes=30)


print(datetime.now().replace(day=1, hour=0, minute=0, second=0, microsecond=0))

formatTT = 'ММ'
print(', '.join(formatTT))
formatTT = formatTT.split()
print(formatTT)
print("""Принадлежность - 
{0}""".format("'" + "', '".join(formatTT) + "'"))